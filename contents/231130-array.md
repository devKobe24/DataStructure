# Swift Standard Library

Swift 표준 라이브러리는 Swift 언어의 핵심 구성 요소를 담고 있는 프레임워크입니다.
여기에서는 Swift 앱을 구축하는 데 도움이 되는 다양한 도구와 유형을 찾을 수 있습니다.

**자체 맞춤형 데이터 구조를 만들기 시작하기 전에, Swift 표준 라이브러리가 이미 제공하는 주요 데이터구조를 이해하는 것이 중요합니다.**

이번 글에서는 표준 라이브러리가 제공하는 주요 데이터 구조 중 하나인 **"배열(Array)"** 에 초점을 맞출 것입니다.

# 배열(Array) 🧩

**"배열(Array)"** 은 다양한 Swift 프로그램에서 흔히 사용되는, **순서가 있는 요소들의 모음을 저장하기 위한 범용적이고 일반적인 컨테이너입니다.**

배열은 배열 리터럴(array literal), 즉 대괄호로 둘러싸인 쉼표로 구분된 값들의 목록을 사용하여 생성할 수 있습니다.

예를 들어 다음과 같습니다.

```swift
let people = ["Brian", "Stanley", "Ringo"]
```

Swift는 프로토콜을 사용하여 배열을 정의합니다.
이러한 프로토콜 각각은 배열에 더 많은 기능을 더해줍니다.

예를 들어, 배열은 시퀀스(Sequence)이므로, 적어도 한 번은 반복해서 순회할 수 있습니다.
또한 컬렉션(Collection)이므로, 여러 번 비파괴적으로 순회하고 첨자 연산자(subscript operator)를 사용하여 접근할 수 있습니다.

배열은 또한 랜덤 액세스 컬렉션(RandomAccessCollection)이기도 하여, 효율성에 대한 보장을 제공합니다.

Swift의 배열은 어떤 타입과도 작동할 수 있는 일반적인 컬렉션이라고 알려져 있습니다.
실제로 Swift 표준 라이브러리의 대부분은 일반적인 코드로 구축되어 있습니다.

어떤 데이터 구조와 마찬가지로, 인지해야 할 특정한 특징들이 있습니다.
이 중 첫 번째는 **순서(order)** 의 개념입니다.

## 1️⃣ Order(순서)

배열 내의 요소들은 명확하게 순서가 지정됩니다.
위의 `people` 배열을 예로 들면, `"Brian"`은 `"Stanley"` 보다 앞에 옵니다.

배열의 모든 요소는 해당하는 0부터 시작하는 정수 인덱스를 가집니다.

예를 들어, 위의예시에서 `people` 배열은 세 개의 인덱스를 가지고 있으며, 각각의 요소에 해당합니다.
배열 내의 요소 값을 다음과 같이 검색할 수 있습니다.

```swift
people[0] // "Brian"
people[1] // "Stanley"
people[2] // "Ringo"
```

**순서(order)는 배열 데이터 구조에 의해 정의되며, 당연하게 여겨져서는 안됩니다.**

`"Dictionary"` 과 같은 일부 데이터 구조는 순서(order)에 대해 더 약한 개념을 가지고 있습니다.

### 1.1 Random-access.

**"랜덤 액세스"는 데이터 구조가 일정한 시간 내에 요소를 검색할 수 있을 때 주장할 수 있는 특성입니다.**

예를 들어, `people` 배열에서 `"Ringo"` 를 가져오는 것은 일정한 시간이 걸립니다.

다시 말하지만, 이러한 성능은 당연한 것으로 여겨져서는 안됩니다.

링크드 리스트(linked lists)나 트리(trees)와 같은 다른 데이터 구조들은 일정한 시간 접근을 가지고 있지 않습니다.

## 2️⃣ Array performance.

랜덤 액세스 컬렉션일 뿐만 아니라, 개발자로서 관심을 가져야 할 다른 성능 영역은 데이터 구조가 포함하는 데이터의 양이 커져야 할 때 얼마나 잘 또는 잘못 작동하는지입니다.

배열의 경우, 이는 두 가지 요소에 따라 다릅니다.

### 2.1 Insertion location(삽입 위치).

첫 번째 요소는 배열 내에 새 요소를 삽입하기로 선택한 위치입니다.

배열에 요소를 추가하는 가장 효율적인 시나리오는 배열의 끝에 추가하는 것입니다.

```swift
people.append("Charles")
print(people) // ["Braian", "Stanley", "Ringo", "Charles"] 출력
```

`append` 메소드를 사용하여 **"Charles"** 를 삽입하면 이 문자열은 배열의 끝에 위치하게 됩니다.

이것은 상수 시간 작업으로, 배열의 크기와 관계없이 이 작업을 수행하는 데 걸리는 시간이 동일하게 유지됩니다.
그러나 배열의 중간 등 특정 위치에 요소를 삽입해야 할 때가 올 수 있습니다.

예를 들어 봅시다.

놀이기구를 타기위해 줄을 서 있습니다.
새로운 사람이 줄에 합류하려고 합니다.
줄에 사람을 추가하기 가장 쉬운 곳은 어디일까요?
물론 끝부분입니다!

만약 새로운 사람이 줄의 중간에 들어오려고 하면, 줄의 절반을 설득해서 자리를 만들어주게 해야합니다.

그리고 만약 그가 매우 무례하게 줄의 맨 앞에 들어가려고 한다면, 이것은 최악의 시나리오입니다.
새 사람을 앞에 두기 위해 줄에 있는 모든 사람이 뒤로 이동해야 합니다!

이것이 바로 배열이 작동하는 방식입니다.

배열의 끝이 아닌 곳에 새 요소를 삽입하면, 새 요소를 위해 다른 요소들이 뒤로 이동해야 합니다.

```swift
people.insert("Andy", at: 0)
// ["Andy", "Brian", "Stanley", "Ringo", "Charles"]
```

정확하게 말하자면, 모든 요소가 한 인덱스씩 뒤로 이동해야 하며, 이는 n 단계가 걸립니다.

배열의 요소 수가 두 배가 되면, 이 삽입 작업에 필요한 시간도 두 배가 됩니다.

컬렉션의 맨 앞에 요소를 삽입하는 것이 프로그램에서 일반적인 작업이라면, 데이터를 저장하기 위해 다른 데이터 구조를 고려할 수도 있습니다.

삽입 속도를 결정하는 두 번째 요소는 **"배열의 용량(array's capacity)"** 입니다.

내부적으로, Swift 배열은 요소를 위한 예정된 양의 공간을 할당받습니다.

이미 최대 용량에 도달한 배열에 새로운 요소를 추가하려고 하면, 배열은 더 많은 요소를 위한 공간을 만들기 위해 자체적으로 재구조화해야 합니다.

이는 메모리 내의 새롭고 더 큰 컨테이너에 배열의 모든 현재 요소를 복사하는 것으로 수행됩니다.
그러나 이는 비용이 들며, 배열의 각 요소를 방문하고 복사해야 합니다.

이는 삽입이 복사가 발생하는 경우에는 끝에서조차도 n 단계가 걸릴 수 있음을 의미합니다.
그러나 표준 라이브러리는 이 복사가 필요한 횟수를 최소화하는 전략을 사용합니다.
저장공간이 부족해지고 복사가 필요할 때마다 용량을 두 배로 늘립니다.
